\chapter{Introduction}\label{ch1}

With the rise of the Internet of Things (IoT), more smart devices (sensors, actuators, etc.) will be deployed in people's life everywhere. Large number of these devices brings up new challenges to applications. 

Traditional Cloud based solution may not be enough for IoT applications with low-latency requirements. Thus new concepts and paradigms such as Fog Computing \cite{Bonomi:2012:FCR:2342509.2342513} have been proposed, which moves computing gradually to the edge of the network and enables even larger scale network of devices to be involved smoothly. The Fog usually consists of many distributed nodes that sit between devices with very constrained resources like sensors and actuators and platform which is more unconstrained and resource-rich, such as the cloud. The fact that a Fog is not as powerful as cloud but must execute some complex tasks on behalf of many low-end devices puts some performance demand on it, similar to traditional backend services.

Another challenge is that existing communication protocols may not fit well in the IoT space. Typical IoT applications intend to consist of a lot of resource-constrained devices such as sensors, data collectors, actuators, controllers or other embedded devices. Many of them will not be able to handle complex protocols solely relying on their own limited resources. Network bandwidth is also limited in constrained environment. Therefore popular web protocols like HTTP should be reconsidered when it comes to IoT applications due to the overhead. To smooth this problem, many new protocols emerged, including but not limited to CoAP \cite{coap_protocol}, MQTT \cite{mqtt_protocol} and DDS \cite{dds}. Among them, The Constrained Application Protocol (CoAP), as a lightweight and efficient application protocol, targets the problem by using low-overhead UDP as its transport layer to ease the stress in constrained environment. It also embraces REST style so that interactions with existing web becomes easier. Beyond that, CoAP supports asynchronous message notification, a.k.a. Observe, to fit in subscriber models used by many IoT applications. 

Regardless of paradigms and protocols, IoT applications in general place high requirements on infrastructures. Scalability and reliability become more important than ever. One constrained device may not be able to send large amount of data at once or send data very frequently, but millions of them could result in huge amount of ongoing data traffic, which requires more scalable backends. It is desired that the software could scale on demand. On the other hand, as more cyber-physical or mission-critical systems, such as industrial control systems, smart cities, and connected cars, are connected to the IoT, uninterrupted and safe operation is often the top priority \cite{7498684}. In another word, downtime due to failure of subsystems should be minimized. This is where reliability must be emphasized more than before. 

An industry with totally different targets but similar requirements is telecommunication, since large amount of in and out phone calls must be handled concurrently in a system with very low downtime. The high concurrency implies a system which could scale up and down while the low downtime implies a fault-tolerant system with high availability, thus reliability. Back to 1980s, one of the top telecom equipment manufacturers, Ericsson, attempted to solve the problem by introducing a new programming environment called Erlang \cite{erl}. Erlang approached the problem by following the famous Actor Model \cite{agha1986actors}, which models the desired system as a combination of many independent, isolated, concurrent actors communicating only through messages. Erlang leads to a new programming paradigm called COP (Concurrency-Oriented Programming) \cite{armstrong2003concurrency} and has influenced many subsequent languages such as Go \cite{go} and Scala \cite{scala}.  

Erlang is proved to be suitable for building massively scalable soft real-time systems with requirements on high availability. As an instance of Erlang's application in real world, the AXD301 is a fault-tolerant carrier-class ATM (Asynchronous Transfer Mode) switch manufactured by Ericsson Telecom AB, which has the measured reliability quoted as being 99.9999999\% (9 nines) corresponding to a down time of 31 ms per year \cite{armstrong2003concurrency}. Nevertheless, very few research of applying Erlang or COP in general in the IoT area have been presented. A. Sivieri et al. \cite{Sivieri:2012:DPT:2667049.2667051} proposed an Erlang-based development framework called ELIoT which aims at coordination of wireless sensor network. R. Hiesgen et al. \cite{7034296} introduced a modified Actor Model and runtime environment based on C++ to IoT application programming, where the authors listed Erlang as a design reference and gave an example implementation utilizing CoAP as communication channel among actors.  

The similarity between the requirements of IoT applications and the design goal of the language leads us to this research. In order to explore the use space of COP language in the IoT world, we attempt to use the typical COP language Erlang to model a CoAP infrastructure (server and client) prototype called ecoap, aiming at scalability and reliability in both constrained (Fog) and unconstrained (Cloud) environment.

Subsequent chapters are organized as follows. Chapter \ref{ch2} gives a more detailed definition of the research problem. Chapter \ref{ch3} presents the literature review of the state-of-the-art work, including comparison of popular IoT application protocols, description of important features of CoAP that are relevant to this work and summary of existing CoAP implementations. It is followed by chapter \ref{ch4} which argues the difference between the current paradigms of mainstream server-side design and typical Erlang applications first, and then presents the architecture of the proposed solution as well as implementation details. After that chapter \ref{ch5} demonstrates a scalability benchmark (comparisons to Californium, a popular Java CoAP implemantation, on both constrained and cloud platform) and a fault-tolerance benchmark 
against ecoap itself. At the end, Chapter \ref{ch6} shows the limitations of the research, the conclusion and contribution as well as future work.





