\chapter{Introduction}\label{ch1}

With the rise of the Internet of Things (IoT), more smart devices (sensors, actuators, etc.) will be deployed in people's life everywhere. Large number of these devices brings up new challenges to applications. Traditional Cloud based solution may not be enough for IoT applications with low-latency requirements. Thus new concepts and paradigms such as Fog Computing \cite{Bonomi:2012:FCR:2342509.2342513} have been proposed, which moves computing gradually to the edge of the network and enables even larger scale network of devices to be involved smoothly. 

Another challenge is that existing communication protocols may not fit very well in IoT space. A typical IoT world is where millions of low-cost devices can detect and communicate to each other when necessary but only use small amount of data for each communication. Though one device may not be able to send large amount of data at once or send data very frequently, many of them could consist of huge number of ongoing data traffic. To smooth this problem, many new protocols emerged, including but not limited to CoAP \cite{coap_protocol}, MQTT \cite{mqtt_protocol}, DDS \cite{dds}. Among them, CoAP (The Constrained Application Protocol), as a lightweight and efficient application protocol, targets the problem by using low-overhead UDP as its transport layer to ease the stress in constrained environment. It also embraces REST style so that interactions with existing web becomes easier. Beyond that, CoAP supports asynchronous message notification, a.k.a. Observe, to fit in subscriber models used by many IoT applications. 
 
Regardless of paradigms and protocols, IoT application also places high requirements on its infrastructures. Scalability and reliability become more important than ever in order to both support huge amount of data traffic and manage such scale of devices effectively. An industry with totally different targets but similar requirements is telecommunication, since large amount of in and out phone calls must be handled concurrently in a system with very low downtime. The high concurrency implies a system which could scale up and down while the low downtime implies a fault-tolerant system with high availability, thus reliability. Back to 1990s, one of the top telecom equipment manufacturers, Ericsson, attempted to solve the problem by introducing a new programming environment called Erlang \cite{erl}. Erlang approached the problem by following the famous Actor Model \cite{agha1986actors}, which models the desired system as a combination of many independent, isolated, concurrent actors communicating only through messages. Erlang leads to a new programming paradigm called COP (Concurrency-Oriented Programming) \cite{armstrong2003concurrency} and has influenced many subsequent languages such as Go \cite{go} and Scala \cite{scala}.

However, very few research of applying COP in IoT area have been presented. Take Erlang as an example, Alessandro Sivieri et al. \cite{Sivieri:2012:DPT:2667049.2667051} proposed a an Erlang-based development framework called ELIoT which aims at coordination of wireless sensor network. 

Therefore, the similarity between the requirements of IoT applications and the design goal of the language lead us to this research. The research approaches the goal of scalability and reliability from an application's point of view. In detail, we attempt to use Erlang, as a typical COP language, together with CoAP, to model a server prototype which targets at scalability and reliability both in constrained (Fog) and unconstrained (Cloud) environment, in order to explore the use space of Erlang in IoT world. 

Subsequent chapters are organized as follows. Chapter \ref{ch2} gives more detailed definition of the research problem. Chapter \ref{ch3} presents the literature review of the state-of-the-art work, including application paradigm, protocols and their current implementations. It is followed by chapter \ref{ch4} which discusses the architecture of the proposed solution. And then chapter \ref{ch5} gives the evaluation experiments and data. At the end, Chapter \ref{ch6} shows the conclusion, contribution and future work.