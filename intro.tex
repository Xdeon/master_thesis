\chapter{Introduction}\label{ch1}

With the rise of the Internet of Things (IoT), more smart devices (sensors, actuators, etc.) will be deployed in people's life everywhere. Large number of these devices brings up new challenges to applications. 

Traditional Cloud based solution may not be enough for IoT applications with low-latency requirements. Thus new concepts and paradigms such as Fog Computing \autocite{Bonomi:2012:FCR:2342509.2342513} have been proposed, which moves computing gradually to the edge of the network and enables even larger scale network of devices to be involved smoothly. The Fog usually consists of many distributed nodes that sit between devices with very constrained resources like sensors and actuators and platform which is more unconstrained and resource-rich, such as the cloud. The fact that a Fog is not as powerful as cloud but often executes some complex tasks on behalf of many low-end devices puts some performance demand on it, similar to traditional backend services.

Another challenge is that existing communication protocols do not fit well in the IoT space. Typical IoT applications are intended to consist of many resource-constrained devices such as sensors, data collectors, actuators, controllers or other embedded devices. Many of them will not be able to handle complex protocols solely relying on their own limited resources. Network bandwidth is also limited in constrained environment. Therefore popular Web protocols like HTTP should be reconsidered when it comes to IoT applications due to the overhead. To smooth this problem, many new protocols emerged, including but not limited to CoAP \autocite{coap_protocol}, MQTT \autocite{mqtt_protocol} and DDS \autocite{dds}. Among them, the Constrained Application Protocol (CoAP), as a lightweight and efficient application layer protocol, targets the problem by using low-overhead UDP as its transport layer to ease the stress in constrained environment. It also embraces REST style so that interactions with existing Web becomes easier. Beyond that, CoAP supports asynchronous message notification, a.k.a. Observe, to fit in the subscriber model that is widely used in many IoT scenarios. 

Regardless of paradigms and protocols, IoT applications in general place high requirements on infrastructures. Scalability and reliability become more important. One constrained device may not be able to send large volume data at once or send data very frequently, but millions of them could result in huge amount of ongoing data traffic, which requires more scalable backends. It is desired that the software could scale on demand. On the other hand, as more cyber-physical or mission-critical systems, such as industrial control systems, smart cities, and connected cars, are connected to the IoT, uninterrupted and safe operation is often the top priority \autocite{7498684}. In another word, downtime due to failure of subsystems should be minimized. This is where reliability must be emphasized more than ever. 

An industry with totally different targets but similar requirements is telecommunication, since large amount of in and out phone calls must be handled concurrently in a system with very low downtime. The high concurrency implies a system which could scale up and down while the low downtime implies a fault-tolerant system with high availability, hence reliability. Back to 1980s, one of the top telecom equipment manufacturers, Ericsson, attempted to solve the problem by introducing a new programming environment called Erlang \autocite{erl}. Erlang approached the problem by following the famous actor model \autocite{agha1986actors}, which models the desired system as a combination of many independent, isolated, concurrent actors communicating only through messages. Erlang leads to a new programming paradigm called concurrency-oriented programming (COP) \autocite{armstrong2003concurrency} and has influenced many subsequent languages such as Go \autocite{go} and Scala \autocite{scala}.  

Erlang is proved to be suitable for building massively scalable soft real-time systems with requirements on high availability. As an instance of Erlang's application in real world, the AXD301 is a fault-tolerant carrier-class ATM switch manufactured by Ericsson Telecom AB, which has the measured reliability quoted as being 99.9999999\% (9 nines) corresponding to a down time of 31 ms per year \autocite{armstrong2003concurrency}. Nevertheless, very few research of applying Erlang or COP in general in the IoT area have been presented. \textcite{Sivieri:2012:DPT:2667049.2667051} proposed an Erlang-based development framework called ELIoT which aims at coordination of wireless sensor network. \textcite{7034296} introduced a modified actor model and corresponding runtime environment built with C++ to IoT application programming, where the authors listed Erlang as a design reference and gave an example implementation utilizing CoAP as the communication channel among actors.  

The similarity between the requirements of IoT applications and the design goal of Erlang leads us to this research. In order to explore the use space of COP language in the IoT world, this work attempted to use the typical COP language Erlang to model a CoAP infrastructure (server and client) and demonstrate a prototype implementation called ecoap, aiming at scalability and reliability in both constrained (Fog) and unconstrained (Cloud) environment.

Subsequent chapters are organized as follows. \autoref{ch2} gives a more precise definition of the research problem. \autoref{ch3} presents the literature review of the state-of-the-art work, including comparison of popular IoT application protocols, introduction of important features of CoAP that are relevant to this work and summary of existing CoAP implementations. It is followed by \autoref{ch4}, which firstly argues the difference between the popular paradigms of designing concurrent server-side software and typical Erlang applications, and then presents the architecture of the proposed solution as well as implementation details. After that \autoref{ch5} demonstrates a scalability benchmark conducted on both constrained and unconstrained platform (in comparison to the Californium (Cf) CoAP framework \autocite{californium}, a popular Java CoAP implementation) and a fault-tolerance benchmark against ecoap itself. At the end, \autoref{ch6} shows the limitations of the research, the conclusion and contribution as well as future work.





